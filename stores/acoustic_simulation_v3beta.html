<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced 2D Acoustic FDTD Simulation</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            box-sizing: border-box;
        }
        
        body { 
            font-family: 'Inter', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; 
            margin: 0; 
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%); 
            color: #eee; 
            display: flex; 
            height: 100vh; 
            overflow: hidden;
        }
        
        #sidebar { 
            width: 380px; 
            background: rgba(27, 27, 43, 0.95); 
            padding: 20px; 
            overflow-y: auto; 
            display: flex; 
            flex-direction: column; 
            gap: 16px; 
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .panel { 
            background: rgba(40, 40, 60, 0.8); 
            padding: 16px; 
            border-radius: 12px; 
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .panel h3 { 
            margin: 0 0 12px 0; 
            font-size: 16px; 
            font-weight: 600;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2); 
            padding-bottom: 8px; 
            color: #ffffff;
        }
        
        canvas { 
            background: rgba(20, 20, 30, 0.9); 
            border-radius: 12px; 
            display: block; 
            image-rendering: pixelated; 
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        label { 
            display: inline-block; 
            margin-right: 8px; 
            font-size: 13px; 
            color: #ddd; 
            font-weight: 500;
        }
        
        input[type=range] { 
            vertical-align: middle; 
            width: 120px; 
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #2b6cff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(43, 108, 255, 0.4);
        }
        
        input[type=range]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #2b6cff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(43, 108, 255, 0.4);
        }
        
        button { 
            background: linear-gradient(135deg, #2b6cff 0%, #1e4fd1 100%); 
            color: white; 
            border: none; 
            padding: 10px 16px; 
            border-radius: 8px; 
            cursor: pointer; 
            width: 100%; 
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(43, 108, 255, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(43, 108, 255, 0.4);
        }
        
        button.secondary { 
            background: linear-gradient(135deg, #444 0%, #333 100%); 
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }
        
        button.secondary:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }
        
        .control-group { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 12px; 
        }
        
        .control-group label { 
            flex-basis: 40%; 
        }
        
        #main-content { 
            flex-grow: 1; 
            padding: 20px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            position: relative;
        }
        
        #footer { 
            margin-top: 12px; 
            font-size: 12px; 
            color: #aaa; 
            text-align: center; 
            opacity: 0.8;
        }
        
        select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: #fff;
            padding: 6px 8px;
            font-size: 13px;
        }
        
        select:focus {
            outline: none;
            border-color: #2b6cff;
            box-shadow: 0 0 0 2px rgba(43, 108, 255, 0.2);
        }
        
        .value-display {
            color: #2b6cff;
            font-weight: 600;
            min-width: 40px;
            text-align: right;
        }
        
        .tooltip {
            position: relative;
            cursor: help;
        }
        
        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 1000;
        }
        
        .tooltip:hover::after {
            opacity: 1;
        }
        
        #waveform-canvas {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            height: 100px;
            background: rgba(20, 20, 30, 0.8);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #observation-canvas {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            height: 150px;
            background: rgba(20, 20, 30, 0.8);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }
        
        .preset-buttons button {
            padding: 8px 12px;
            font-size: 12px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
            margin-left: 8px;
        }
        
        .status-indicator.active {
            background: #2b6cff;
            box-shadow: 0 0 8px rgba(43, 108, 255, 0.6);
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulse-animation {
            animation: pulse 2s infinite;
        }
        
        .interference-pattern {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            color: #2b6cff;
        }
        
        .observation-point {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 3px solid #ff6b35;
            border-radius: 50%;
            background: rgba(255, 107, 53, 0.3);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }
        
        .observation-info {
            position: absolute;
            top: 180px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            color: #fff;
            min-width: 280px;
        }
        
        .observation-info h4 {
            margin: 0 0 8px 0;
            color: #ff6b35;
            font-size: 14px;
        }
        
        .observation-info .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }
        
        .observation-info .metric-value {
            color: #2b6cff;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div class="panel">
            <h3>シミュレーション制御 <span class="status-indicator" id="status-indicator"></span></h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <button id="run" class="pulse-animation">開始</button>
                <button id="pause" class="secondary">停止</button>
            </div>
            <div style="margin-top: 12px;">
                <button id="reset" class="secondary">リセット</button>
            </div>
        </div>

        <div class="panel">
            <h3>設定</h3>
            <div class="control-group">
                <label class="tooltip" data-tooltip="グリッドの解像度を変更">解像度</label>
                <select id="res">
                    <option value="64">軽い (64x64)</option>
                    <option value="128" selected>中 (128x128)</option>
                    <option value="200">重い (200x200)</option>
                    <option value="256">超高 (256x256)</option>
                </select>
            </div>
            <div class="control-group">
                <label class="tooltip" data-tooltip="境界での音波の吸収率">吸収層強度</label>
                <input id="damp" type="range" min="0" max="1" step="0.01" value="0.7">
                <span id="dampVal" class="value-display">0.70</span>
            </div>
            <div class="control-group">
                <label class="tooltip" data-tooltip="音波の可視化色">カラーマップ</label>
                <select id="colormap">
                    <option value="diverging" selected>Red/Blue</option>
                    <option value="viridis">Viridis</option>
                    <option value="grayscale">Grayscale</option>
                    <option value="plasma">Plasma</option>
                    <option value="heatmap">Heatmap</option>
                </select>
            </div>
            <div class="control-group">
                <label class="tooltip" data-tooltip="シミュレーション速度">速度</label>
                <input id="speed" type="range" min="1" max="10" step="1" value="3">
                <span id="speedVal" class="value-display">3</span>
            </div>
        </div>

        <div class="panel">
            <h3>音源</h3>
            <div class="control-group">
                <label class="tooltip" data-tooltip="音の周波数">周波数 (Hz)</label>
                <input id="freq" type="range" min="100" max="8000" step="10" value="1500">
                <span id="freqVal" class="value-display">1500</span>
            </div>
            <div class="control-group">
                <label class="tooltip" data-tooltip="音の大きさ">振幅</label>
                <input id="amp" type="range" min="0.1" max="3" step="0.1" value="1">
                <span id="ampVal" class="value-display">1.0</span>
            </div>
            <div class="control-group">
                <label class="tooltip" data-tooltip="音源の種類">ソースタイプ</label>
                <select id="sourcetype">
                    <option value="tone" selected>連続正弦波</option>
                    <option value="pulse">短パルス</option>
                    <option value="sweep">周波数スイープ</option>
                    <option value="noise">ホワイトノイズ</option>
                </select>
            </div>
            <div class="control-group">
                <label class="tooltip" data-tooltip="実際の音を再生">オーディオ出力</label>
                <input type="checkbox" id="audio-output">
            </div>
        </div>

        <div class="panel">
            <h3>描画ツール</h3>
            <div class="control-group">
                <label class="tooltip" data-tooltip="描画モード">モード</label>
                <select id="drawmode">
                    <option value="wall" selected>壁</option>
                    <option value="erase">消しゴム</option>
                    <option value="source">ソース配置</option>
                    <option value="observer">観測地点</option>
                </select>
            </div>
            <div class="control-group">
                <label class="tooltip" data-tooltip="図形プリセット">プリセット</label>
                <select id="preset-shape">
                    <option value="none" selected>なし</option>
                    <option value="rect">四角形</option>
                    <option value="circle">円</option>
                    <option value="triangle">三角形</option>
                </select>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 12px;">
                <button id="undo" class="secondary">元に戻す</button>
                <button id="redo" class="secondary">やり直し</button>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px;">
                <button id="clear" class="secondary">壁をクリア</button>
                <button id="clear-sources" class="secondary">ソースをクリア</button>
            </div>
            <div style="margin-top: 8px;">
                <button id="clear-observers" class="secondary">観測地点をクリア</button>
            </div>
        </div>

        <div class="panel">
            <h3>プリセットシナリオ</h3>
            <div class="preset-buttons">
                <button id="preset-empty">空間</button>
                <button id="preset-room">部屋</button>
                <button id="preset-maze">迷路</button>
                <button id="preset-waveguide">導波管</button>
                <button id="preset-resonator">共振器</button>
                <button id="preset-obstacles">障害物</button>
                <button id="preset-interference">干渉管</button>
                <button id="preset-shotgun">ショットガンマイク</button>
            </div>
        </div>

        <div class="panel">
            <h3>データ</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                <button id="export" class="secondary">壁を保存</button>
                <button id="import" class="secondary">壁を読込</button>
                <button id="screenshot" class="secondary">スクリーンショット</button>
                <button id="record" class="secondary">録画開始</button>
            </div>
            <input type="file" id="import-file" style="display: none" accept=".json">
        </div>
    </div>

    <div id="main-content">
        <canvas id="canvas" width="640" height="640"></canvas>
        <canvas id="waveform-canvas" width="600" height="100"></canvas>
        <canvas id="observation-canvas" width="300" height="150"></canvas>
        <div class="observation-info" id="observation-info" style="display: none;">
            <h4>観測地点情報</h4>
            <div class="metric">
                <span>位置:</span>
                <span class="metric-value" id="observer-position">-</span>
            </div>
            <div class="metric">
                <span>音圧レベル:</span>
                <span class="metric-value" id="sound-pressure-level">0.0 dB</span>
            </div>
            <div class="metric">
                <span>瞬時振幅:</span>
                <span class="metric-value" id="instantaneous-amplitude">0.00</span>
            </div>
            <div class="metric">
                <span>RMS値:</span>
                <span class="metric-value" id="rms-value">0.00</span>
            </div>
            <div class="metric">
                <span>周波数:</span>
                <span class="metric-value" id="observed-frequency">- Hz</span>
            </div>
        </div>
        <div id="footer">
            描画モードを選択し、左ドラッグで描画・消去。音源はクリックで配置。<br>
            観測地点モードでクリックすると観測地点を配置。<br>
            キーボードショートカット: Space(開始/停止) R(リセット) Z(元に戻す) Y(やり直し)
        </div>
        <div class="interference-pattern" id="interference-info" style="display: none;">
            干渉パターン可視化中
        </div>
    </div>

    <script>
        // ====== Advanced 2D FDTD Acoustic Simulation ======
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const waveformCanvas = document.getElementById('waveform-canvas');
        const waveformCtx = waveformCanvas.getContext('2d');
        const observationCanvas = document.getElementById('observation-canvas');
        const observationCtx = observationCanvas.getContext('2d');
        
        let Nx = 128, Ny = 128;
        let gridW = canvas.width, gridH = canvas.height;
        let cellW = gridW / Nx, cellH = gridH / Ny;
        
        let p = null, pOld = null, pNew = null;
        let obstacle = null;
        let sources = [];
        let observers = [];
        let running = false;
        let lastTime = 0;
        let stepsPerFrame = 2;
        let simulationSpeed = 3;
        
        const c = 343.0;
        let domainSize = 0.30;
        let dx = domainSize / Nx;
        let dt = dx / (c * Math.SQRT2) * 0.6;
        
        // Audio context
        let audioContext = null;
        let audioEnabled = false;
        let oscillator = null;
        let gainNode = null;
        
        // Observation data
        let observationHistory = [];
        const MAX_OBSERVATION_HISTORY = 300;
        let currentObserver = null;
        
        // UI elements
        const resEl = document.getElementById('res');
        const freqEl = document.getElementById('freq');
        const freqVal = document.getElementById('freqVal');
        const ampEl = document.getElementById('amp');
        const ampVal = document.getElementById('ampVal');
        const speedEl = document.getElementById('speed');
        const speedVal = document.getElementById('speedVal');
        const runBtn = document.getElementById('run');
        const pauseBtn = document.getElementById('pause');
        const clearBtn = document.getElementById('clear');
        const clearSourcesBtn = document.getElementById('clear-sources');
        const clearObserversBtn = document.getElementById('clear-observers');
        const resetBtn = document.getElementById('reset');
        const drawMode = document.getElementById('drawmode');
        const sourceType = document.getElementById('sourcetype');
        const dampEl = document.getElementById('damp');
        const dampVal = document.getElementById('dampVal');
        const colormapEl = document.getElementById('colormap');
        const presetShapeEl = document.getElementById('preset-shape');
        const exportBtn = document.getElementById('export');
        const importBtn = document.getElementById('import');
        const importFileEl = document.getElementById('import-file');
        const screenshotBtn = document.getElementById('screenshot');
        const recordBtn = document.getElementById('record');
        const audioOutputEl = document.getElementById('audio-output');
        const statusIndicator = document.getElementById('status-indicator');
        const interferenceInfo = document.getElementById('interference-info');
        const observationInfo = document.getElementById('observation-info');
        
        const undoBtn = document.getElementById('undo');
        const redoBtn = document.getElementById('redo');
        
        let undoStack = [];
        let redoStack = [];
        const MAX_HISTORY = 50;
        
        // Recording
        let mediaRecorder = null;
        let isRecording = false;
        
        // Preset buttons
        const presetEmptyBtn = document.getElementById('preset-empty');
        const presetRoomBtn = document.getElementById('preset-room');
        const presetMazeBtn = document.getElementById('preset-maze');
        const presetWaveguideBtn = document.getElementById('preset-waveguide');
        const presetResonatorBtn = document.getElementById('preset-resonator');
        const presetObstaclesBtn = document.getElementById('preset-obstacles');
        const presetInterferenceBtn = document.getElementById('preset-interference');
        const presetShotgunBtn = document.getElementById('preset-shotgun');
        
        function updateUndoRedoButtons() {
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
        }
        
        function saveStateForUndo() {
            redoStack = [];
            undoStack.push(new Uint8Array(obstacle));
            if (undoStack.length > MAX_HISTORY) {
                undoStack.shift();
            }
            updateUndoRedoButtons();
        }
        
        undoBtn.addEventListener('click', () => {
            if (undoStack.length > 0) {
                const prevState = undoStack.pop();
                redoStack.push(new Uint8Array(obstacle));
                obstacle.set(prevState);
                if (!running) drawField();
                updateUndoRedoButtons();
            }
        });
        
        redoBtn.addEventListener('click', () => {
            if (redoStack.length > 0) {
                const nextState = redoStack.pop();
                undoStack.push(new Uint8Array(obstacle));
                obstacle.set(nextState);
                if (!running) drawField();
                updateUndoRedoButtons();
            }
        });
        
        // UI event listeners
        freqEl.addEventListener('input', () => {
            freqVal.textContent = freqEl.value;
            updateAudioFrequency();
            document.getElementById('observed-frequency').textContent = freqEl.value + ' Hz';
        });
        
        ampEl.addEventListener('input', () => {
            ampVal.textContent = Number(ampEl.value).toFixed(1);
            updateAudioVolume();
        });
        
        speedEl.addEventListener('input', () => {
            speedVal.textContent = speedEl.value;
            simulationSpeed = Number(speedEl.value);
            updateSimulationSpeed();
        });
        
        dampEl.addEventListener('input', () => {
            dampVal.textContent = Number(dampEl.value).toFixed(2);
            baseDampStrength = Number(dampEl.value);
            dampMask = makeDampingMask(baseDampStrength);
        });
        
        resEl.addEventListener('change', () => {
            Nx = Number(resEl.value);
            Ny = Nx;
            restartSimulation();
        });
        
        audioOutputEl.addEventListener('change', () => {
            audioEnabled = audioOutputEl.checked;
            if (audioEnabled) {
                initAudio();
            } else {
                stopAudio();
            }
        });
        
        clearObserversBtn.addEventListener('click', () => {
            observers = [];
            currentObserver = null;
            observationHistory = [];
            observationInfo.style.display = 'none';
            if (!running) drawField();
        });
        
        function allocFields() {
            p = new Float32Array(Nx*Ny).fill(0);
            pOld = new Float32Array(Nx*Ny).fill(0);
            pNew = new Float32Array(Nx*Ny).fill(0);
            obstacle = new Uint8Array(Nx*Ny).fill(0);
            cellW = canvas.width / Nx;
            cellH = canvas.height / Ny;
            dx = domainSize / Nx;
            dt = dx / (c * Math.SQRT2) * 0.6;
            updateSimulationSpeed();
        }
        
        function updateSimulationSpeed() {
            if (Nx <= 64) stepsPerFrame = simulationSpeed * 2;
            else if (Nx <= 128) stepsPerFrame = simulationSpeed;
            else stepsPerFrame = Math.max(1, Math.floor(simulationSpeed / 2));
        }
        
        allocFields();
        
        function idx(i,j) { return i + j*Nx; }
        
        function makeDampingMask(strength=0.7) {
            const mask = new Float32Array(Nx*Ny).fill(1.0);
            const thickness = Math.max(8, Math.floor(0.08 * Math.max(Nx,Ny)));
            for (let j=0;j<Ny;j++){
                for (let i=0;i<Nx;i++){
                    let di = Math.min(i, Nx-1-i);
                    let dj = Math.min(j, Ny-1-j);
                    let edge = Math.min(di,dj);
                    if (edge < thickness) {
                        const r = (thickness - edge)/thickness;
                        mask[idx(i,j)] = 1.0 - strength * (r*r);
                    }
                }
            }
            return mask;
        }
        
        let baseDampStrength = Number(dampEl.value);
        let dampMask = makeDampingMask(baseDampStrength);
        
        function stepForward(tGlobal) {
            const omega = 2*Math.PI*Number(freqEl.value);
            const amp = Number(ampEl.value);
            const sourceTypeVal = sourceType.value;
            
            const coef = (c*c) * (dt*dt);
            
            for (let j=1;j<Ny-1;j++){
                let base = j * Nx;
                for (let i=1;i<Nx-1;i++){
                    const k = base + i;
                    if (obstacle[k]) {
                        pNew[k] = 0;
                        continue;
                    }
                    const lap = (p[k+1] + p[k-1] + p[k+Nx] + p[k-Nx] - 4*p[k]) / (dx*dx);
                    pNew[k] = 2*p[k] - pOld[k] + coef * lap;
                }
            }
            
            for (let s of sources){
                const k = idx(s.i,s.j);
                if (sourceTypeVal === 'tone') {
                    const val = amp * Math.sin(omega * tGlobal);
                    pNew[k] += val;
                } else if (sourceTypeVal === 'pulse') {
                    const tau = 1.5e-4;
                    const dtPhysical = tGlobal - s.t0;
                    const pulse = amp * Math.exp(- (dtPhysical*dtPhysical) / (tau*tau));
                    pNew[k] += pulse;
                } else if (sourceTypeVal === 'sweep') {
                    const sweepRate = 1000;
                    const freq = Number(freqEl.value) + sweepRate * tGlobal;
                    const val = amp * Math.sin(2*Math.PI*freq * tGlobal);
                    pNew[k] += val;
                } else if (sourceTypeVal === 'noise') {
                    const val = amp * (Math.random() * 2 - 1);
                    pNew[k] += val;
                }
            }
            
            for (let j=0;j<Ny;j++){
                for (let i=0;i<Nx;i++){
                    const k = idx(i,j);
                    pNew[k] *= dampMask[k];
                }
            }
            
            const tmp = pOld; pOld = p; p = pNew; pNew = tmp;
            
            // 観測地点でのデータ収集
            updateObservationData();
        }
        
        function updateObservationData() {
            if (observers.length === 0) return;
            
            for (let obs of observers) {
                const k = idx(obs.i, obs.j);
                const pressure = p[k];
                
                // 観測履歴に追加
                if (!obs.history) obs.history = [];
                obs.history.push(pressure);
                if (obs.history.length > MAX_OBSERVATION_HISTORY) {
                    obs.history.shift();
                }
                
                // RMS値の計算
                let sumSquares = 0;
                for (let val of obs.history) {
                    sumSquares += val * val;
                }
                obs.rms = Math.sqrt(sumSquares / obs.history.length);
                
                // 音圧レベル (dB) の計算
                const refPressure = 20e-6; // 聴覚の閾値
                obs.soundPressureLevel = 20 * Math.log10(Math.abs(pressure) / refPressure + 1e-10);
                
                // 瞬時振幅
                obs.instantaneousAmplitude = pressure;
            }
            
            // 現在選択されている観測地点の情報を更新
            if (currentObserver) {
                updateObservationInfo();
            }
        }
        
        function updateObservationInfo() {
            if (!currentObserver) return;
            
            document.getElementById('observer-position').textContent = 
                `(${currentObserver.i}, ${currentObserver.j})`;
            document.getElementById('sound-pressure-level').textContent = 
                currentObserver.soundPressureLevel.toFixed(1) + ' dB';
            document.getElementById('instantaneous-amplitude').textContent = 
                currentObserver.instantaneousAmplitude.toFixed(3);
            document.getElementById('rms-value').textContent = 
                currentObserver.rms.toFixed(3);
        }
        
        function colorMap(v){
            const cmap = colormapEl.value;
            const t = Math.max(-1, Math.min(1, v));
            
            switch(cmap) {
                case 'diverging':
                    if (t > 0){
                        const r = Math.min(255, Math.floor(80 + 175 * t));
                        const g = Math.floor(80 * (1 - t));
                        const b = Math.floor(80 * (1 - t));
                        return [r,g,b];
                    } else {
                        const tt = -t;
                        const r = Math.floor(80 * (1 - tt));
                        const g = Math.floor(80 * (1 - tt));
                        const b = Math.min(255, Math.floor(80 + 175 * tt));
                        return [r,g,b];
                    }
                case 'viridis':
                    const c = (t + 1) / 2;
                    const r = Math.floor(255 * Math.sqrt(c));
                    const g = Math.floor(255 * c*c*c);
                    const b = Math.floor(255 * (0.5 * Math.sin(c * Math.PI)));
                    return [r, g, b];
                case 'plasma':
                    const p = (t + 1) / 2;
                    const pr = Math.floor(255 * Math.sin(p * Math.PI));
                    const pg = Math.floor(255 * Math.sin(p * Math.PI + Math.PI/3));
                    const pb = Math.floor(255 * Math.sin(p * Math.PI + 2*Math.PI/3));
                    return [pr, pg, pb];
                case 'heatmap':
                    const h = (t + 1) / 2;
                    const hr = Math.min(255, Math.floor(255 * h));
                    const hg = Math.floor(255 * h * h);
                    const hb = Math.floor(255 * h * h * h);
                    return [hr, hg, hb];
                default:
                    const l = Math.floor(255 * (t+1)/2);
                    return [l,l,l];
            }
        }
        
        function drawField() {
            const image = ctx.createImageData(canvas.width, canvas.height);
            const data = image.data;
            
            let maxVal = 1e-6;
            for (let k=0;k<Nx*Ny;k++){
                const v = Math.abs(p[k]);
                if (v > maxVal) maxVal = v;
            }
            
            for (let j=0;j<Ny;j++){
                for (let i=0;i<Nx;i++){
                    const k = idx(i,j);
                    const x0 = Math.floor(i * cellW);
                    const y0 = Math.floor(j * cellH);
                    const x1 = Math.floor((i+1) * cellW);
                    const y1 = Math.floor((j+1) * cellH);
                    
                    const val = p[k] / maxVal;
                    const col = colorMap(val);
                    
                    for (let yy=y0; yy<y1; yy++){
                        for (let xx=x0; xx<x1; xx++){
                            const idxPix = (yy*canvas.width + xx) * 4;
                            data[idxPix] = col[0];
                            data[idxPix+1] = col[1];
                            data[idxPix+2] = col[2];
                            data[idxPix+3] = 255;
                        }
                    }
                    
                    if (obstacle[k]) {
                        for (let yy=y0; yy<y1; yy++){
                            for (let xx=x0; xx<x1; xx++){
                                const idxPix = (yy*canvas.width + xx) * 4;
                                data[idxPix] = 30;
                                data[idxPix+1] = 30;
                                data[idxPix+2] = 30;
                                data[idxPix+3] = 255;
                            }
                        }
                    }
                }
            }
            ctx.putImageData(image,0,0);
            
            drawSources();
            drawObservers();
            drawWaveform();
            drawObservationWaveform();
            drawInterferencePattern();
        }
        
        function drawSources() {
            ctx.fillStyle = '#2b6cff';
            for (let s of sources) {
                const x = s.i * cellW + cellW/2;
                const y = s.j * cellH + cellH/2;
                ctx.beginPath();
                ctx.arc(x, y, Math.max(4, cellW/3), 0, 2*Math.PI);
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(x, y, Math.max(6, cellW/2), 0, 2*Math.PI);
                ctx.stroke();
            }
        }
        
        function drawObservers() {
            for (let obs of observers) {
                const x = obs.i * cellW + cellW/2;
                const y = obs.j * cellH + cellH/2;
                
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, Math.max(8, cellW/2), 0, 2*Math.PI);
                ctx.stroke();
                
                // 観測地点の中心点
                ctx.fillStyle = currentObserver === obs ? '#ff6b35' : 'rgba(255, 107, 53, 0.5)';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2*Math.PI);
                ctx.fill();
            }
        }
        
        function drawWaveform() {
            waveformCtx.fillStyle = 'rgba(20, 20, 30, 0.8)';
            waveformCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            
            if (sources.length > 0) {
                waveformCtx.strokeStyle = '#2b6cff';
                waveformCtx.lineWidth = 2;
                waveformCtx.beginPath();
                
                const centerY = waveformCanvas.height / 2;
                const amplitude = 30;
                
                for (let x = 0; x < waveformCanvas.width; x++) {
                    const t = (x / waveformCanvas.width) * 0.01;
                    const omega = 2*Math.PI*Number(freqEl.value);
                    const y = centerY + amplitude * Math.sin(omega * t) * Math.exp(-t*100);
                    
                    if (x === 0) {
                        waveformCtx.moveTo(x, y);
                    } else {
                        waveformCtx.lineTo(x, y);
                    }
                }
                waveformCtx.stroke();
            }
            
            waveformCtx.fillStyle = '#666';
            waveformCtx.font = '12px Inter';
            waveformCtx.fillText('Source Waveform', 10, 20);
        }
        
        function drawObservationWaveform() {
            observationCtx.fillStyle = 'rgba(20, 20, 30, 0.8)';
            observationCtx.fillRect(0, 0, observationCanvas.width, observationCanvas.height);
            
            if (observers.length > 0 && currentObserver && currentObserver.history) {
                const history = currentObserver.history;
                const centerY = observationCanvas.height / 2;
                const maxAmplitude = 50;
                
                // 波形を描画
                observationCtx.strokeStyle = '#ff6b35';
                observationCtx.lineWidth = 2;
                observationCtx.beginPath();
                
                for (let i = 0; i < history.length; i++) {
                    const x = (i / history.length) * observationCanvas.width;
                    const y = centerY - (history[i] * maxAmplitude);
                    
                    if (i === 0) {
                        observationCtx.moveTo(x, y);
                    } else {
                        observationCtx.lineTo(x, y);
                    }
                }
                observationCtx.stroke();
                
                // グリッド線
                observationCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                observationCtx.lineWidth = 1;
                observationCtx.beginPath();
                observationCtx.moveTo(0, centerY);
                observationCtx.lineTo(observationCanvas.width, centerY);
                observationCtx.stroke();
            }
            
            observationCtx.fillStyle = '#666';
            observationCtx.font = '12px Inter';
            observationCtx.fillText('Observed Waveform', 10, 20);
        }
        
        function drawInterferencePattern() {
            if (sources.length >= 2) {
                interferenceInfo.style.display = 'block';
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                
                for (let i = 0; i < sources.length - 1; i++) {
                    for (let j = i + 1; j < sources.length; j++) {
                        const s1 = sources[i];
                        const s2 = sources[j];
                        const x1 = s1.i * cellW + cellW/2;
                        const y1 = s1.j * cellH + cellH/2;
                        const x2 = s2.i * cellW + cellW/2;
                        const y2 = s2.j * cellH + cellH/2;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
                ctx.setLineDash([]);
            } else {
                interferenceInfo.style.display = 'none';
            }
        }
        
        let tSim = 0;
        function loop(now){
            if (!running) return;
            
            for (let s=0; s<stepsPerFrame; s++){
                stepForward(tSim);
                tSim += dt;
            }
            drawField();
            requestAnimationFrame(loop);
        }
        
        let isMouseDown = false;
        let lastCell = null;
        let startCell = null;
        
        canvas.addEventListener('pointerdown', (ev) => {
            ev.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = ev.clientX - rect.left;
            const y = ev.clientY - rect.top;
            const i = Math.floor(x / cellW);
            const j = Math.floor(y / cellH);
            isMouseDown = true;
            lastCell = [i,j];
            startCell = [i,j];
            
            if (presetShapeEl.value === 'none') {
                saveStateForUndo();
                handleDraw(i,j, ev);
            }
        });
        
        canvas.addEventListener('pointermove', (ev) => {
            if (!isMouseDown || presetShapeEl.value !== 'none') return;
            const rect = canvas.getBoundingClientRect();
            const x = ev.clientX - rect.left;
            const y = ev.clientY - rect.top;
            const i = Math.floor(x / cellW);
            const j = Math.floor(y / cellH);
            if (i === lastCell?.[0] && j === lastCell?.[1]) return;
            lastCell = [i,j];
            handleDraw(i,j, ev);
        });
        
        canvas.addEventListener('pointerup', (ev) => {
            if (presetShapeEl.value !== 'none') {
                saveStateForUndo();
                const rect = canvas.getBoundingClientRect();
                const x = ev.clientX - rect.left;
                const y = ev.clientY - rect.top;
                const i = Math.floor(x / cellW);
                const j = Math.floor(y / cellH);
                drawPreset(startCell[0], startCell[1], i, j, drawMode.value);
            }
            isMouseDown = false;
            lastCell = null;
            startCell = null;
            if (!running) drawField();
        });
        
        canvas.addEventListener('click', (ev) => {
            const rect = canvas.getBoundingClientRect();
            const x = ev.clientX - rect.left;
            const y = ev.clientY - rect.top;
            const i = Math.floor(x / cellW);
            const j = Math.floor(y / cellH);
            
            if (drawMode.value === 'source'){
                sources.push({i:i, j:j, t0:tSim});
                if (!running) drawField();
            } else if (drawMode.value === 'observer'){
                // 既存の観測地点をチェック
                let existingObserver = null;
                for (let obs of observers) {
                    if (obs.i === i && obs.j === j) {
                        existingObserver = obs;
                        break;
                    }
                }
                
                if (existingObserver) {
                    // 既存の観測地点を選択
                    currentObserver = existingObserver;
                } else {
                    // 新規観測地点を追加
                    const newObserver = {i:i, j:j, history:[], rms:0, soundPressureLevel:0, instantaneousAmplitude:0};
                    observers.push(newObserver);
                    currentObserver = newObserver;
                }
                
                observationInfo.style.display = 'block';
                updateObservationInfo();
                if (!running) drawField();
            }
        });
        
        function handleDraw(i,j, ev) {
            if (i<0 || i>=Nx || j<0 || j>=Ny) return;
            const k = idx(i,j);
            const mode = drawMode.value;
            
            if (mode === 'wall'){
                obstacle[k] = 1;
            } else if (mode === 'erase'){
                obstacle[k] = 0;
            }
            if (!running) drawField();
        }
        
        function drawPreset(i0, j0, i1, j1, mode) {
            const shape = presetShapeEl.value;
            const value = (mode === 'erase') ? 0 : 1;
            
            switch(shape) {
                case 'rect':
                    const iMin = Math.min(i0, i1);
                    const iMax = Math.max(i0, i1);
                    const jMin = Math.min(j0, j1);
                    const jMax = Math.max(j0, j1);
                    for (let j = jMin; j <= jMax; j++) {
                        for (let i = iMin; i <= iMax; i++) {
                            if (i<0 || i>=Nx || j<0 || j>=Ny) continue;
                            obstacle[idx(i,j)] = value;
                        }
                    }
                    break;
                    
                case 'circle':
                    const ci = Math.floor((i0+i1)/2);
                    const cj = Math.floor((j0+j1)/2);
                    const ri = Math.abs(i1-i0)/2;
                    const rj = Math.abs(j1-j0)/2;
                    if (ri === 0 || rj === 0) return;
                    for (let j = 0; j < Ny; j++) {
                        for (let i = 0; i < Nx; i++) {
                            if (((i-ci)/ri)**2 + ((j-cj)/rj)**2 < 1) {
                                if (i<0 || i>=Nx || j<0 || j>=Ny) continue;
                                obstacle[idx(i,j)] = value;
                            }
                        }
                    }
                    break;
                    
                case 'triangle':
                    const ti0 = i0, ti1 = i1, tj0 = j0, tj1 = j1;
                    const tcx = (ti0 + ti1) / 2;
                    const tcy = tj0;
                    const base = Math.abs(ti1 - ti0);
                    const height = Math.abs(tj1 - tj0);
                    
                    for (let j = Math.min(tj0, tj1); j <= Math.max(tj0, tj1); j++) {
                        const y = j - tcy;
                        const width = base * (1 - Math.abs(y) / height);
                        for (let i = tcx - width/2; i <= tcx + width/2; i++) {
                            if (i<0 || i>=Nx || j<0 || j>=Ny) continue;
                            obstacle[idx(Math.floor(i), j)] = value;
                        }
                    }
                    break;
            }
        }
        
        // Preset scenarios
        presetEmptyBtn.addEventListener('click', () => {
            saveStateForUndo();
            obstacle.fill(0);
            sources.length = 0;
            observers.length = 0;
            currentObserver = null;
            observationInfo.style.display = 'none';
            if (!running) drawField();
        });
        
        presetRoomBtn.addEventListener('click', () => {
            saveStateForUndo();
            obstacle.fill(0);
            const thickness = Math.max(2, Math.floor(Nx * 0.1));
            for (let j=0;j<Ny;j++){
                for (let i=0;i<Nx;i++){
                    if (i < thickness || i >= Nx-thickness || j < thickness || j >= Ny-thickness) {
                        obstacle[idx(i,j)] = 1;
                    }
                }
            }
            if (!running) drawField();
        });
        
        presetMazeBtn.addEventListener('click', () => {
            saveStateForUndo();
            obstacle.fill(0);
            const cellSize = Math.max(4, Math.floor(Nx / 16));
            for (let j=0;j<Ny;j+=cellSize){
                for (let i=0;i<Nx;i+=cellSize){
                    if ((i/cellSize + j/cellSize) % 2 === 0) {
                        for (let dj=0;dj<cellSize-1;dj++){
                            for (let di=0;di<cellSize-1;di++){
                                if (i+di < Nx && j+dj < Ny) {
                                    obstacle[idx(i+di, j+dj)] = 1;
                                }
                            }
                        }
                    }
                }
            }
            if (!running) drawField();
        });
        
        presetWaveguideBtn.addEventListener('click', () => {
            saveStateForUndo();
            obstacle.fill(0);
            const thickness = Math.max(3, Math.floor(Ny * 0.2));
            for (let j=0;j<thickness;j++){
                for (let i=0;i<Nx;i++){
                    obstacle[idx(i,j)] = 1;
                    obstacle[idx(i,Ny-1-j)] = 1;
                }
            }
            if (!running) drawField();
        });
        
        presetResonatorBtn.addEventListener('click', () => {
            saveStateForUndo();
            obstacle.fill(0);
            const centerX = Math.floor(Nx/2);
            const centerY = Math.floor(Ny/2);
            const radius = Math.floor(Math.min(Nx,Ny) * 0.3);
            
            for (let j=0;j<Ny;j++){
                for (let i=0;i<Nx;i++){
                    const dist = Math.sqrt((i-centerX)**2 + (j-centerY)**2);
                    if (Math.abs(dist - radius) < 2) {
                        obstacle[idx(i,j)] = 1;
                    }
                }
            }
            if (!running) drawField();
        });
        
        presetObstaclesBtn.addEventListener('click', () => {
            saveStateForUndo();
            obstacle.fill(0);
            const numObstacles = 8;
            for (let k=0;k<numObstacles;k++){
                const x = Math.floor(Math.random() * Nx);
                const y = Math.floor(Math.random() * Ny);
                const size = Math.floor(Math.random() * 8) + 3;
                
                for (let j=Math.max(0,y-size);j<Math.min(Ny,y+size);j++){
                    for (let i=Math.max(0,x-size);i<Math.min(Nx,x+size);i++){
                        if (Math.sqrt((i-x)**2 + (j-y)**2) < size) {
                            obstacle[idx(i,j)] = 1;
                        }
                    }
                }
            }
            if (!running) drawField();
        });
        // 干渉管プリセット（1px壁＋等間隔スリット）
        presetInterferenceBtn.addEventListener('click', () => {
            saveStateForUndo();
            obstacle.fill(0);
            sources.length = 0;
            observers.length = 0;
            currentObserver = null;

            // === 幾何パラメータ ===
            const centerY = Math.floor(Ny / 2);

            // 管の長さ・内径（内部の空間サイズ）
            const innerLeft   = Math.max(2, Math.floor(Nx * 0.15));
            const innerRight  = Math.min(Nx - 3, Math.floor(Nx * 0.85));
            const innerHeight = Math.max(12, Math.floor(Ny * 0.16)); // 内径（セル数）
            const innerTop    = Math.max(1, centerY - Math.floor(innerHeight / 2));
            const innerBottom = Math.min(Ny - 2, centerY + Math.floor(innerHeight / 2));

            // 壁の位置（1px厚）
            const topWallY    = innerTop;       // 上壁
            const bottomWallY = innerBottom;    // 下壁
            const leftWallX   = innerLeft;      // 左壁
            const rightWallX  = innerRight;     // 右壁

            // スリット（等間隔で“壁セルを作らない”＝穴）設定
            const slitPeriod = Math.max(5, Math.floor((innerRight - innerLeft) / 40)); // スリット周期
            const slitWidth  = 1;   // スリット幅（1セル）
            const slitOffset = 0;   // 開始位置オフセット

            // 口（開口部）幅：左端の縦方向に壁を作らない範囲
            const mouthHalf = Math.max(2, Math.floor(innerHeight * 0.25)); // 口の半幅
            const mouthTop = Math.max(0, centerY - mouthHalf);
            const mouthBottom = Math.min(Ny - 1, centerY + mouthHalf);

            // === 上下の壁（1px）を引き、等間隔にスリットを空ける ===
            for (let x = innerLeft; x <= innerRight; x++) {
                // スリット位置判定（周期ごとに幅slitWidth分は穴）
                const inTopSlit    = (((x - innerLeft - slitOffset) % slitPeriod) + slitPeriod) % slitPeriod < slitWidth;
                const inBottomSlit = (((x - innerLeft - Math.floor(slitPeriod / 2)) % slitPeriod) + slitPeriod) % slitPeriod < slitWidth;

                // 上壁
                if (!inTopSlit && inBounds(x, topWallY)) {
                    obstacle[idx(x, topWallY)] = 1;
                }
                // 下壁
                if (!inBottomSlit && inBounds(x, bottomWallY)) {
                    obstacle[idx(x, bottomWallY)] = 1;
                }
            }

            // === 左右の壁（1px）。左端は“口”として中央付近を開ける ===
            for (let y = innerTop; y <= innerBottom; y++) {
                // 左壁：口の範囲だけは開ける
                if (!(y >= mouthTop && y <= mouthBottom) && inBounds(leftWallX, y)) {
                    obstacle[idx(leftWallX, y)] = 1;
                }
                // 右壁：完全に閉じる（必要ならここも開けたい場合は条件を追加）
                if (inBounds(rightWallX, y)) {
                    obstacle[idx(rightWallX, y)] = 1;
                }
            }

            // === 音源・観測点の配置 ===
            // 音源は口の外側（左側）中央に1点
            const srcX = Math.max(0, innerLeft - 5);
            const srcY = centerY;
            if (inBounds(srcX, srcY)) {
                sources.push({ i: srcX, j: srcY, t0: 0 });
            }

            // 観測点は管の右端近く（内部）
            const obsX = Math.max(innerLeft + 1, innerRight - 3);
            const obsY = centerY;
            if (inBounds(obsX, obsY)) {
                const newObserver = {
                    i: obsX, j: obsY,
                    history: [], rms: 0,
                    soundPressureLevel: 0, instantaneousAmplitude: 0,
                    estimatedFrequency: 0
                };
                observers.push(newObserver);
                currentObserver = newObserver;
                observationInfo.style.display = 'block';
            } else {
                observationInfo.style.display = 'none';
            }

            if (!running) drawField();
        });
        
        // ショットガンマイクプリセット
        presetShotgunBtn.addEventListener('click', () => {
            saveStateForUndo();
            obstacle.fill(0);
            sources.length = 0;
            observers.length = 0;
            currentObserver = null;
            
            // ショットガンマイクの筒状構造
            const tubeRadius = Math.max(2, Math.floor(Nx * 0.03));
            const tubeLength = Math.max(30, Math.floor(Nx * 0.7));
            const startX = Math.floor(Nx * 0.1);
            const centerY = Math.floor(Ny / 2);
            
            // 筒状の壁を作成
            for (let x = 0; x < tubeLength; x++) {
                for (let r = 0; r < tubeRadius; r++) {
                    for (let angle = 0; angle < 360; angle += 10) {
                        const rad = angle * Math.PI / 180;
                        const i = Math.floor(startX + x + r * Math.cos(rad));
                        const j = Math.floor(centerY + r * Math.sin(rad));
                        if (i >= 0 && i < Nx && j >= 0 && j < Ny) {
                            obstacle[idx(i, j)] = 1;
                        }
                    }
                }
            }
            
            // 筒の内部を空ける
            for (let x = 0; x < tubeLength - 5; x++) {
                for (let r = 0; r < tubeRadius - 1; r++) {
                    for (let angle = 0; angle < 360; angle += 30) {
                        const rad = angle * Math.PI / 180;
                        const i = Math.floor(startX + x + r * Math.cos(rad));
                        const j = Math.floor(centerY + r * Math.sin(rad));
                        if (i >= 0 && i < Nx && j >= 0 && j < Ny) {
                            obstacle[idx(i, j)] = 0;
                        }
                    }
                }
            }
            
            // 音源を筒の前方に配置
            sources.push({i: Math.floor(startX + tubeLength + 5), j: centerY, t0: 0});
            
            // マイクカプセルを筒の後方に配置（観測地点）
            const micObserver = {i: Math.floor(startX + 5), j: centerY, history:[], rms:0, soundPressureLevel:0, instantaneousAmplitude:0};
            observers.push(micObserver);
            currentObserver = micObserver;
            observationInfo.style.display = 'block';
            
            if (!running) drawField();
        });
        
        // Controls
        runBtn.addEventListener('click', () => {
            if (!running){
                running = true;
                statusIndicator.classList.add('active');
                if(tSim === 0) {
                    p.fill(0);
                    pOld.fill(0);
                    pNew.fill(0);
                }
                requestAnimationFrame(loop);
            }
        });
        
        pauseBtn.addEventListener('click', () => {
            running = false;
            statusIndicator.classList.remove('active');
        });
        
        clearBtn.addEventListener('click', () => {
            saveStateForUndo();
            obstacle.fill(0);
            if (!running) drawField();
        });
        
        clearSourcesBtn.addEventListener('click', () => {
            sources.length = 0;
            if (!running) drawField();
        });
        
        resetBtn.addEventListener('click', () => {
            p.fill(0); pOld.fill(0); pNew.fill(0); sources.length = 0; observers.length = 0; currentObserver = null; tSim = 0;
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();
            statusIndicator.classList.remove('active');
            observationInfo.style.display = 'none';
            if (!running) drawField();
        });
        
        // Audio functions
        async function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            
            oscillator = audioContext.createOscillator();
            gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(Number(freqEl.value), audioContext.currentTime);
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            
            oscillator.start();
        }
        
        function updateAudioFrequency() {
            if (oscillator && audioEnabled) {
                oscillator.frequency.setValueAtTime(Number(freqEl.value), audioContext.currentTime);
            }
        }
        
        function updateAudioVolume() {
            if (gainNode && audioEnabled && running) {
                gainNode.gain.setValueAtTime(Number(ampEl.value) * 0.1, audioContext.currentTime);
            }
        }
        
        function stopAudio() {
            if (gainNode) {
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            }
        }
        
        // Export/Import
        exportBtn.addEventListener('click', () => {
            const data = {
                resolution: { Nx, Ny },
                obstacles: Array.from(obstacle),
                sources: sources,
                observers: observers,
                timestamp: new Date().toISOString()
            };
            const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `acoustic_simulation_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });
        
        importBtn.addEventListener('click', () => importFileEl.click());
        importFileEl.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.resolution && data.obstacles) {
                        saveStateForUndo();
                        Nx = data.resolution.Nx;
                        Ny = data.resolution.Ny;
                        const resOption = Array.from(resEl.options).find(o => o.value == Nx);
                        if(resOption) resEl.value = resOption.value;
                        
                        restartSimulation();
                        obstacle = new Uint8Array(data.obstacles);
                        if (data.sources) {
                            sources = data.sources;
                        }
                        if (data.observers) {
                            observers = data.observers;
                            if (observers.length > 0) {
                                currentObserver = observers[0];
                                observationInfo.style.display = 'block';
                            }
                        }
                        if (!running) drawField();
                    } else {
                        alert('Invalid simulation file format.');
                    }
                } catch (err) {
                    alert('Error reading simulation file: ' + err.message);
                }
            };
            reader.readAsText(file);
        });
        
        screenshotBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `acoustic_simulation_${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        });
        
        recordBtn.addEventListener('click', async () => {
            if (!isRecording) {
                try {
                    const stream = canvas.captureStream(30);
                    mediaRecorder = new MediaRecorder(stream, {mimeType: 'video/webm'});
                    const chunks = [];
                    
                    mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, {type: 'video/webm'});
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `acoustic_simulation_${Date.now()}.webm`;
                        a.click();
                        URL.revokeObjectURL(url);
                    };
                    
                    mediaRecorder.start();
                    isRecording = true;
                    recordBtn.textContent = '録画停止';
                    recordBtn.style.background = 'linear-gradient(135deg, #ff4444 0%, #cc0000 100%)';
                } catch (err) {
                    alert('録画を開始できません: ' + err.message);
                }
            } else {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                isRecording = false;
                recordBtn.textContent = '録画開始';
                recordBtn.style.background = 'linear-gradient(135deg, #444 0%, #333 100%)';
            }
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (ev) => {
            if (ev.code === 'Space') {
                ev.preventDefault();
                if (running) {
                    pauseBtn.click();
                } else {
                    runBtn.click();
                }
            } else if (ev.code === 'KeyR' && ev.ctrlKey) {
                ev.preventDefault();
                resetBtn.click();
            } else if (ev.code === 'KeyZ' && ev.ctrlKey) {
                ev.preventDefault();
                undoBtn.click();
            } else if (ev.code === 'KeyY' && ev.ctrlKey) {
                ev.preventDefault();
                redoBtn.click();
            }
        });
        
        function restartSimulation(){
            allocFields();
            dampMask = makeDampingMask(baseDampStrength);
            p.fill(0); pOld.fill(0); pNew.fill(0);
            sources.length = 0;
            observers.length = 0;
            currentObserver = null;
            tSim = 0;
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();
            if (!running) drawField();
        }
        
        // Initialize
        updateUndoRedoButtons();
        drawField();
        
        // Add some initial sources for demonstration
        sources.push({i: Math.floor(Nx/2), j: Math.floor(Ny/2), t0: 0});
        if (!running) drawField();
    </script>
</body>
</html>